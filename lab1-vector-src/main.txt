#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <stdint.h>

#include <chrono>
#include <vector>
#include <tuple>
#include <thread>

#include "tree.h"  // 包含树的定义文件，假设MyTree在此定义

#define THREAD_MAX  // 可能用于定义最大线程数（但未使用）

// 遍历查询的线程函数，具体实现未提供
void traverse_queries(MyTree* tree, std::vector<std::tuple<MyTree::MyNode*, uint64_t>> queries, int thread_id, int thread_cnt, uint64_t* return_cnt);

int main (int argc, char** argv) {
    // 检查输入参数是否满足要求
    if ( argc < 5 ) {
        printf( "usage: %s [input filename] [val cnt] [query file] [thread cnt]\n", argv[0] );
        exit(1);
    }

    // 打开输入文件（存储键值对的数据文件）
    FILE* fin = fopen( argv[1], "rb");
    if ( NULL == fin ) {
        printf( "Failed to open input file\n" );
        exit(1);
    }

    // 读取 value 数组的大小
    size_t valcnt = atoi(argv[2]);
    if ( valcnt < 4 || valcnt > 8192 ) {
        printf( "Exceeds arbitrary limitation on value array size\n" );
        exit(1);
    }

    // 打开查询文件
    FILE* finq = fopen( argv[3], "rb" );
    if ( NULL == finq ) {
        printf( "Failed to open query file\n" );
        exit(1);
    }

    // 获取线程数量，限制最大值
    int thread_cnt = atoi(argv[4]);
    if ( thread_cnt < 1 ) thread_cnt = 1;
    if ( thread_cnt > 1024 ) thread_cnt = 1024;

    // 创建树对象
    MyTree* tree = new MyTree();

    // 记录插入数据的起始时间
    std::chrono::high_resolution_clock::time_point start = std::chrono::high_resolution_clock::now();

    // 读取并插入数据
    void* valbuf = malloc(valcnt * sizeof(uint32_t));
    while (!feof(fin)) {
        uint64_t key;
        size_t rres = fread(&key, sizeof(uint64_t), 1, fin);
        if (rres != 1) continue;

        rres = fread(valbuf, sizeof(uint32_t), valcnt, fin);

        // 创建新节点并插入到树中
        MyTree::MyNode* nn = new MyTree::MyNode(key, valbuf, valcnt * sizeof(uint32_t));
        tree->Insert(nn);
    }
    
    // 计算插入数据所用的时间
    std::chrono::high_resolution_clock::time_point now = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> elapsed = std::chrono::duration_cast<std::chrono::duration<double>>(now - start);
    printf("Done inserting all data. Elapsed %.02fs\n", elapsed.count());
    fflush(stdout);

    // 读取查询数据
    std::vector<std::tuple<MyTree::MyNode*, uint64_t>> queries;
    while (!feof(finq)) {
        uint64_t from, to;
        size_t rres = fread(&from, sizeof(uint64_t), 1, finq);
        if (rres != 1) continue;
        rres = fread(&to, sizeof(uint64_t), 1, finq);
        if (rres != 1) continue;

        rres = fread(valbuf, sizeof(uint32_t), valcnt, finq);
        MyTree::MyNode* nn = new MyTree::MyNode(from, valbuf, valcnt * sizeof(uint32_t));
        queries.push_back({nn, to});
    }

    printf("Finished reading the query file. %ld requests.\n", queries.size());
    fflush(stdout);

    // 计算查询结果的总和
    uint64_t ans_sum = 0;
    std::vector<std::thread*> threads;
    threads.reserve(thread_cnt);

    std::vector<uint64_t> return_cnts;
    return_cnts.reserve(thread_cnt);

    // 记录查询开始时间
    start = std::chrono::high_resolution_clock::now();

    // 多线程执行查询
    for (int i = 0; i < thread_cnt; i++) {
        return_cnts[i] = 0;
        threads[i] = new std::thread(traverse_queries, tree, queries, i, thread_cnt, &(return_cnts[i]));
    }

    // 等待所有线程完成
    for (int i = 0; i < thread_cnt; i++) {
        threads[i]->join();
        ans_sum += return_cnts[i];
    }

    // 计算查询所用时间
    now = std::chrono::high_resolution_clock::now();
    elapsed = std::chrono::duration_cast<std::chrono::duration<double>>(now - start);
    
    printf("Answer_sum: %ld\n", ans_sum);
    printf("Done querying. Elapsed %.06fs\n", elapsed.count());
    fflush(stdout);

    return 0;
}
